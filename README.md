# MCP Code Execution

> TypeScript implementation of the breakthrough pattern from [Anthropic's "Code Execution with MCP"](https://www.anthropic.com/engineering/code-execution-with-mcp) that reduces token usage by **98.7%** through progressive tool discovery and local data processing.

## Why This Changes Everything

**User request:** "Go out and get the awesome MCP list, save it to my Obsidian vault"

**Traditional approach:** Load 150,000 tokens of tool definitions upfront, flood context with raw GitHub API responses, hope the model can filter signal from noise.

**With progressive disclosure:**

```text
1. LLM explores servers/MCP_DOCKER/ to discover available tools (2,000 tokens)
2. LLM writes tests/awesome-mcp-to-obsidian.ts using only what it needs
3. Script executes locally: GitHub search → README fetch → process → Obsidian write
4. LLM receives clean result: "Saved 47 MCP resources to 0. Inbox/Awesome MCP Resources.md"
```

**Impact:** Task completed with 98.7% fewer tokens. Zero API bloat in context. Clean separation between tool discovery, execution, and results.

This is the pattern that makes AI agents practical at scale.

## Core Capabilities

- **Progressive tool discovery** - Agents explore the filesystem to find tools, not load 150K tokens upfront
- **Lazy server connections** - MCP servers connect on-demand when first called, not at startup
- **Auto-generated TypeScript wrappers** - Fully typed interfaces from JSON schemas
- **Local data processing** - Intermediate results never touch model context

## Installation

```bash
git clone https://github.com/ipdelete/mcp-code-execution.git
cd mcp-code-execution
npm install
```

## Quick Start

### 1. Configure MCP Servers

Edit `mcp-config.json`:

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/private/tmp"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"]
    }
  }
}
```

### 2. Generate TypeScript Wrappers

```bash
npm run generate
```

This introspects all configured MCP servers and creates typed wrapper functions in `servers/`.

### 3. Let Your Agent Write Scripts

**User:** "Find all TypeScript files in /tmp and count how many contain 'async'"

**Agent workflow:**

1. Explores `./servers/` to discover filesystem tools
2. Reads only the tool definitions it needs
3. Writes this script:

```typescript
// Script generated by agent
import { list_directory, read_text_file } from '../servers/filesystem';

async function main() {
  const files = await list_directory({ path: '/tmp' });
  const tsFiles = files.filter(f => f.endsWith('.ts'));

  let asyncCount = 0;
  for (const file of tsFiles) {
    const content = await read_text_file({ path: `/tmp/${file}` });
    if (content.includes('async')) asyncCount++;
  }

  console.log({
    totalTsFiles: tsFiles.length,
    filesWithAsync: asyncCount
  });
}

main();
```

4. Executes with `npm run exec generated-script.ts`
5. Returns only the summary (not raw file contents) to user

## How It Works

### The Progressive Disclosure Pattern

```text
Traditional:           Progressive:
┌─────────────┐       ┌─────────────┐
│ Load all    │       │ Explore     │
│ 150K tokens │       │ ./servers/  │ (2K tokens)
└─────────────┘       └─────────────┘
       ↓                     ↓
┌─────────────┐       ┌─────────────┐
│ Choose      │       │ Read only   │
│ from memory │       │ needed defs │
└─────────────┘       └─────────────┘
       ↓                     ↓
┌─────────────┐       ┌─────────────┐
│ API call    │       │ Write code  │
│ in context  │       │ + execute   │
└─────────────┘       └─────────────┘
       ↓                     ↓
┌─────────────┐       ┌─────────────┐
│ Process     │       │ Process     │
│ in context  │       │ locally     │
└─────────────┘       └─────────────┘
       ↓                     ↓
   Bloated             Clean summary
```

### Architecture

```text
mcp-code-execution/
├── runtime/
│   ├── mcp-client.ts         # Lazy-loading MCP client manager
│   ├── harness.ts            # Script execution harness
│   └── generate-wrappers.ts  # Auto-generation from schemas
├── servers/                  # Generated wrappers (gitignored)
│   ├── filesystem/
│   │   ├── list_directory.ts
│   │   └── index.ts
│   └── github/
│       ├── search_code.ts
│       └── index.ts
├── tests/                    # Agent-generated scripts
└── mcp-config.json          # Server configuration
```

## Generated Wrappers

The generator creates fully-typed interfaces from MCP JSON schemas:

```typescript
// servers/github/search_code.ts (auto-generated)
interface SearchCodeParams {
  q: string;
  order?: 'asc' | 'desc';
  page?: number;
  per_page?: number;
}

export async function search_code(params: SearchCodeParams): Promise<SearchCodeResult> {
  return await callMcpTool<SearchCodeResult>('github__search_code', params);
}
```

Import and use with full type safety:

```typescript
import { search_code } from '../servers/github';

const results = await search_code({ q: 'language:typescript MCP', per_page: 10 });
```

### Schema Discovery for APIs Without Schemas

Many MCP servers don't provide output schemas because the underlying APIs lack formal specifications. The **schema discovery** feature lets you generate TypeScript types from actual API responses:

1. Configure safe (read-only) tools in `discovery-config.json`
2. Run `npm run discover-schemas`
3. Import types from `servers/{server-name}/discovered-types.ts`

```typescript
import { wit_get_work_item } from '../servers/ado';
import type { WitGetWorkItemResult } from '../servers/ado/discovered-types';

const workItem = await wit_get_work_item({ id: 123, project: 'MyProject' }) as WitGetWorkItemResult;
const title = workItem.fields?.['System.Title']; // IntelliSense support!
```

**Note**: Discovered types are optional hints. Always use defensive coding patterns (see `.claude/agents/developer.md` for details).

## Advanced Usage

### Direct API Calls

Skip the wrappers when needed:

```typescript
import { callMcpTool } from '../runtime/mcp-client';

const result = await callMcpTool('github__search_code', {
  q: 'language:typescript MCP',
  per_page: 10
});
```

### Adding New MCP Servers

1. Edit `mcp-config.json`:

```json
{
  "mcpServers": {
    "new-server": {
      "command": "npx",
      "args": ["-y", "@your/mcp-server"]
    }
  }
}
```

2. Regenerate wrappers:

```bash
npm run generate
```

3. Import and use:

```typescript
import { some_tool } from '../servers/new-server';
const result = await some_tool({ param: 'value' });
```

## The Efficiency Gains

| Dimension | Traditional MCP | Code Execution Pattern |
|-----------|----------------|------------------------|
| **Token Usage** | 150,000 (all tools loaded) | 2,000 (progressive discovery) |
| **Server Connections** | All at startup | On-demand per tool |
| **Data Processing** | Through model context | Local execution |
| **Type Safety** | Manual definitions | Auto-generated from schemas |
| **Context Pollution** | High (raw API responses) | Minimal (summaries only) |

## Writing Scripts

All scripts in `tests/` must follow these conventions:

### Process Exit Handling

**ALWAYS include proper exit codes** to ensure scripts terminate cleanly:

```typescript
async function main() {
  // Your logic here
}

main().then(() => {
  process.exit(0);
}).catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});
```

### Error Handling

- Wrap API calls in try-catch blocks
- Handle both success (`process.exit(0)`) and failure (`process.exit(1)`) cases
- Log errors clearly before exiting

### Data Safety

**ALWAYS use defensive coding patterns** since MCP response structures may vary:

```typescript
// Handle both wrapped and direct responses
const data = response.value || response;

// Ensure arrays before using array methods
const items = Array.isArray(data) ? data : [];
items.forEach(item => { /* safe */ });

// Safe property access with fallbacks
const displayName = field?.displayName || field || 'Unknown';

// Combining patterns for complex scenarios
const backlogs = Array.isArray(response.value || response) 
  ? (response.value || response) 
  : [];
const featureBacklog = backlogs.find(b => b.name === 'Features');
```

**Why this matters:** Auto-generated wrappers may not have complete type information. Defensive patterns prevent runtime errors when response structures differ from expectations.

See `tests/list-team-features.ts` for a complete example.

## Scripts

- `npm run generate` - Generate TypeScript wrappers for all configured servers
- `npm run discover-schemas` - Generate TypeScript types from actual API responses
- `npm run exec <script>` - Execute a TypeScript script with MCP support
- `npm run build` - Compile TypeScript to JavaScript

## Example Scripts

- `tests/example-progressive-disclosure.ts` - Complete demonstration of the pattern
- `tests/example-discovered-types.ts` - Using discovered types with defensive coding
- `tests/test-generated-wrappers.ts` - Validates auto-generated wrapper functions

## Requirements

- Node.js 18+
- TypeScript 5+
- MCP SDK

## Troubleshooting

| Issue | Solution |
|-------|----------|
| "MCP server not configured" | Verify server name matches `mcp-config.json` |
| "Connection closed" | Test server installation: `npx -y @modelcontextprotocol/server-name --help` |
| Path access denied (macOS) | Use `/private/tmp` instead of `/tmp` for filesystem operations |
| Missing generated wrappers | Run `npm run generate` to create them |

## Learn More

- [Code Execution with MCP](https://www.anthropic.com/engineering/code-execution-with-mcp) - The original Anthropic engineering article
- [Model Context Protocol](https://modelcontextprotocol.io/) - Official MCP specification
- [MCP Servers](https://github.com/modelcontextprotocol/servers) - Official server implementations

## License

MIT
